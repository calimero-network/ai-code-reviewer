"""GitHub comment formatter for review output."""

from __future__ import annotations

from typing import TYPE_CHECKING

from ai_reviewer.models.findings import Severity
from ai_reviewer.models.review import ConsolidatedReview

if TYPE_CHECKING:
    from ai_reviewer.github.client import ReviewDelta


class GitHubFormatter:
    """Formats review output for GitHub comments."""

    SEVERITY_EMOJI = {
        Severity.CRITICAL: "ðŸ”´",
        Severity.WARNING: "ðŸŸ¡",
        Severity.SUGGESTION: "ðŸ’¡",
        Severity.NITPICK: "ðŸ“",
    }

    SEVERITY_LABEL = {
        Severity.CRITICAL: "Critical",
        Severity.WARNING: "Warning",
        Severity.SUGGESTION: "Suggestion",
        Severity.NITPICK: "Nitpick",
    }

    def format_review(self, review: ConsolidatedReview) -> str:
        """Format a consolidated review as a GitHub comment.

        Args:
            review: Consolidated review to format

        Returns:
            Markdown formatted comment
        """
        lines = [
            "## ðŸ¤– AI Code Review",
            "",
            self._format_header(review),
            "",
            "---",
            "",
        ]

        if not review.findings:
            lines.extend(
                [
                    "### âœ… No Issues Found",
                    "",
                    "All agents reviewed the code and found no issues. LGTM! ðŸŽ‰",
                    "",
                ]
            )
        else:
            # Group by severity
            by_severity = self._group_by_severity(review)

            for severity in [
                Severity.CRITICAL,
                Severity.WARNING,
                Severity.SUGGESTION,
                Severity.NITPICK,
            ]:
                findings = by_severity.get(severity, [])
                if findings:
                    lines.extend(
                        self._format_severity_section(severity, findings, review.agent_count)
                    )
                    lines.append("")

        lines.extend(
            [
                "---",
                "",
                self._format_footer(review),
            ]
        )

        return "\n".join(lines)

    def _format_header(self, review: ConsolidatedReview) -> str:
        """Format the review header."""
        consensus_pct = int(review.review_quality_score * 100)
        time_sec = review.total_review_time_ms / 1000

        return (
            f"**Reviewed by {review.agent_count} agents** | "
            f"Quality score: {consensus_pct}% | "
            f"Review time: {time_sec:.1f}s"
        )

    def _group_by_severity(self, review: ConsolidatedReview) -> dict:
        """Group findings by severity."""
        return self._group_findings_by_severity(review.findings)

    def _format_severity_section(
        self, severity: Severity, findings: list, agent_count: int
    ) -> list[str]:
        """Format a section for a severity level."""
        emoji = self.SEVERITY_EMOJI[severity]
        label = self.SEVERITY_LABEL[severity]

        lines = [
            f"### {emoji} {label} ({len(findings)})",
            "",
        ]

        for i, finding in enumerate(findings, 1):
            # Consensus indicator
            consensus_count = len(finding.agreeing_agents)
            consensus_str = f"{consensus_count}/{agent_count} agents"
            if consensus_count == agent_count:
                consensus_str += " âœ“"

            lines.extend(
                [
                    f"#### {i}. {finding.title}",
                    f"**File:** `{finding.file_path}` (line {finding.line_start}"
                    + (f"-{finding.line_end}" if finding.line_end else "")
                    + f") | **Consensus:** {consensus_str}",
                    "",
                    finding.description,
                    "",
                ]
            )

            if finding.suggested_fix:
                lines.extend(
                    [
                        "**Suggested fix:**",
                        "```",
                        finding.suggested_fix,
                        "```",
                        "",
                    ]
                )

            # Show which agents found this (for transparency)
            agents_str = ", ".join(finding.agreeing_agents[:3])
            if len(finding.agreeing_agents) > 3:
                agents_str += f" (+{len(finding.agreeing_agents) - 3} more)"
            lines.append(f"> *Found by: {agents_str}*")
            lines.append("")

        return lines

    def _format_footer(self, review: ConsolidatedReview) -> str:
        """Format the review footer."""
        return (
            "<sub>ðŸ¤– Generated by "
            "[AI Code Reviewer](https://github.com/calimero-network/ai-code-reviewer) | "
            f"Review ID: `{review.id}`</sub>"
        )

    def format_review_with_delta(
        self,
        review: ConsolidatedReview,
        delta: ReviewDelta,
    ) -> str:
        """Format a review showing changes from previous run.

        Args:
            review: Current consolidated review
            delta: Changes from previous review

        Returns:
            Markdown formatted comment with status indicators
        """
        lines = [
            "## ðŸ¤– AI Code Review",
            "",
            self._format_header(review),
            "",
        ]

        # Add status summary banner
        lines.extend(self._format_status_banner(delta))
        lines.extend(["", "---", ""])

        # Show FIXED issues first (good news!)
        if delta.fixed_findings:
            lines.extend(self._format_fixed_section(delta.fixed_findings))
            lines.append("")

        # Show NEW issues (need attention)
        if delta.new_findings:
            lines.extend(self._format_new_findings_section(delta.new_findings, review.agent_count))
            lines.append("")

        # Show OPEN issues (still pending)
        if delta.open_findings:
            lines.extend(
                self._format_open_findings_section(delta.open_findings, review.agent_count)
            )
            lines.append("")

        # If nothing to show
        if not delta.new_findings and not delta.open_findings and not delta.fixed_findings:
            lines.extend(
                [
                    "### âœ… No Issues Found",
                    "",
                    "All agents reviewed the code and found no issues. LGTM! ðŸŽ‰",
                    "",
                ]
            )

        lines.extend(
            [
                "---",
                "",
                self._format_footer(review),
            ]
        )

        return "\n".join(lines)

    def _format_status_banner(self, delta: ReviewDelta) -> list[str]:
        """Format the status summary banner."""
        if delta.all_issues_resolved:
            return [
                "### âœ… Ready to Merge",
                "",
                "All previously identified issues have been addressed!",
            ]

        new_count = len(delta.new_findings)
        fixed_count = len(delta.fixed_findings)
        open_count = len(delta.open_findings)

        # Status icons
        parts = []
        if fixed_count > 0:
            parts.append(f"âœ… **{fixed_count} Fixed**")
        if new_count > 0:
            parts.append(f"ðŸ†• **{new_count} New**")
        if open_count > 0:
            parts.append(f"â³ **{open_count} Open**")

        status_line = " | ".join(parts)

        # Determine overall status
        has_critical = any(
            f.severity.value == "critical" for f in delta.new_findings + delta.open_findings
        )

        if has_critical:
            status_icon = "ðŸ”´"
            status_text = "Critical issues require attention"
        elif new_count > 0 or open_count > 0:
            status_icon = "ðŸŸ¡"
            status_text = "Issues pending resolution"
        else:
            status_icon = "âœ…"
            status_text = "Ready to merge"

        return [
            f"### {status_icon} {status_text}",
            "",
            status_line,
        ]

    def _format_fixed_section(self, fixed_findings: list) -> list[str]:
        """Format the section showing fixed issues."""
        lines = [
            "### âœ… Fixed Issues",
            "",
            "<details>",
            "<summary>The following issues from previous reviews have been addressed:</summary>",
            "",
        ]

        for i, finding in enumerate(fixed_findings, 1):
            lines.append(f"{i}. ~~{finding.title}~~ (`{finding.file_path}:{finding.line}`)")

        lines.extend(["", "</details>"])
        return lines

    def _format_new_findings_section(self, findings: list, agent_count: int) -> list[str]:
        """Format section for NEW findings."""
        lines = [
            "### ðŸ†• New Issues",
            "",
            "*These issues were found in the latest changes:*",
            "",
        ]

        # Group by severity
        by_severity = self._group_findings_by_severity(findings)

        for severity in [
            Severity.CRITICAL,
            Severity.WARNING,
            Severity.SUGGESTION,
            Severity.NITPICK,
        ]:
            sev_findings = by_severity.get(severity, [])
            if sev_findings:
                lines.extend(self._format_severity_section(severity, sev_findings, agent_count))

        return lines

    def _format_open_findings_section(self, findings: list, agent_count: int) -> list[str]:
        """Format section for OPEN (still unresolved) findings."""
        lines = [
            "### â³ Open Issues",
            "",
            "*These issues from previous reviews are still present:*",
            "",
        ]

        # Group by severity
        by_severity = self._group_findings_by_severity(findings)

        for severity in [
            Severity.CRITICAL,
            Severity.WARNING,
            Severity.SUGGESTION,
            Severity.NITPICK,
        ]:
            sev_findings = by_severity.get(severity, [])
            if sev_findings:
                lines.extend(self._format_severity_section(severity, sev_findings, agent_count))

        return lines

    def _group_findings_by_severity(self, findings: list) -> dict:
        """Group findings by severity."""
        groups: dict = {}
        for finding in findings:
            if finding.severity not in groups:
                groups[finding.severity] = []
            groups[finding.severity].append(finding)
        return groups

    def get_review_action_with_delta(
        self,
        review: ConsolidatedReview,
        delta: ReviewDelta,
        allow_approve: bool = True,
    ) -> str:
        """Determine GitHub review action considering the delta.

        Args:
            review: Consolidated review
            delta: Review delta
            allow_approve: Whether to allow APPROVE action

        Returns:
            GitHub review action
        """
        # If all issues are resolved, approve
        if delta.all_issues_resolved and allow_approve:
            return "APPROVE"

        # If there are critical issues (new or open), request changes
        has_critical = any(
            f.severity.value == "critical" for f in delta.new_findings + delta.open_findings
        )
        if has_critical:
            return "REQUEST_CHANGES"

        # Otherwise, just comment
        return "COMMENT"

    def get_review_action(self, review: ConsolidatedReview, allow_approve: bool = True) -> str:
        """Determine the GitHub review action based on findings.

        Args:
            review: Consolidated review
            allow_approve: Whether to allow APPROVE action (False in GitHub Actions)

        Returns:
            GitHub review action: "APPROVE", "REQUEST_CHANGES", or "COMMENT"
        """
        if review.has_critical_issues:
            return "REQUEST_CHANGES"
        elif not review.findings and allow_approve:
            return "APPROVE"
        else:
            return "COMMENT"


def format_review_as_json(review: ConsolidatedReview) -> dict:
    """Format review as JSON-serializable dict."""
    return {
        "review_id": review.id,
        "created_at": review.created_at.isoformat(),
        "repo": review.repo,
        "pr_number": review.pr_number,
        "summary": review.summary,
        "quality_score": review.review_quality_score,
        "agent_count": review.agent_count,
        "total_time_ms": review.total_review_time_ms,
        "findings": [
            {
                "id": f.id,
                "file_path": f.file_path,
                "line_start": f.line_start,
                "line_end": f.line_end,
                "severity": f.severity.value,
                "category": f.category.value,
                "title": f.title,
                "description": f.description,
                "suggested_fix": f.suggested_fix,
                "consensus_score": f.consensus_score,
                "agreeing_agents": f.agreeing_agents,
                "confidence": f.confidence,
            }
            for f in review.findings
        ],
        "findings_by_severity": {
            k.value: v for k, v in review.findings_by_severity.items() if v > 0
        },
    }
