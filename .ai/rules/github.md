# GitHub Module Rules

## Purpose
The `github/` module handles all GitHub API integration: fetching PR data, posting reviews, and webhook handling.

## File Structure

```
github/
‚îú‚îÄ‚îÄ __init__.py      # Public exports
‚îú‚îÄ‚îÄ client.py        # GitHub API wrapper
‚îú‚îÄ‚îÄ webhook.py       # FastAPI webhook handlers
‚îî‚îÄ‚îÄ formatter.py     # Review output formatting
```

## Key Types

```python
class GitHubClient:
    """Wrapper around PyGitHub for PR operations."""
    
    async def get_pr_diff(self, repo: str, pr_number: int) -> str: ...
    async def get_changed_files(self, repo: str, pr_number: int) -> dict[str, str]: ...
    async def post_review(self, repo: str, pr_number: int, review: ConsolidatedReview): ...
    async def post_inline_comments(self, repo: str, pr_number: int, findings: list): ...

class ReviewFormatter:
    """Formats ConsolidatedReview for different outputs."""
    
    def to_github_markdown(self, review: ConsolidatedReview) -> str: ...
    def to_json(self, review: ConsolidatedReview) -> dict: ...
    def to_cli(self, review: ConsolidatedReview) -> str: ...
```

## Invariants

### G1: Async GitHub Operations
All GitHub API calls are async. Use `httpx` or async PyGitHub wrapper.

### G2: Rate Limiting Awareness
Respect GitHub API rate limits. Use exponential backoff on 429 errors.

### G3: Minimal Data Fetching
Only fetch what's needed. Don't pull entire repo for single PR review.

### G4: Webhook Security
Always validate webhook signatures using `X-Hub-Signature-256` header.

### G5: No Agent Logic in GitHub Module
This module fetches data and posts results. Review logic is in orchestrator.

## Webhook Handling

```python
@app.post("/webhook")
async def github_webhook(request: Request):
    # 1. Validate signature
    signature = request.headers.get("X-Hub-Signature-256")
    if not verify_signature(await request.body(), signature, WEBHOOK_SECRET):
        raise HTTPException(401, "Invalid signature")
    
    # 2. Parse event
    event_type = request.headers.get("X-GitHub-Event")
    payload = await request.json()
    
    # 3. Handle relevant events
    if event_type == "pull_request":
        action = payload["action"]
        if action in ("opened", "synchronize", "reopened"):
            # Queue review (don't block webhook response)
            asyncio.create_task(handle_pr_review(payload))
    
    return {"status": "ok"}
```

## Review Actions

| Scenario | GitHub Review Action |
|----------|---------------------|
| Critical findings | `REQUEST_CHANGES` |
| Warnings/suggestions only | `COMMENT` |
| No findings | `APPROVE` (if configured) |
| Review failed | Comment with error, no action |

## Output Format (GitHub Markdown)

```markdown
## ü§ñ AI Code Review

**Reviewed by {N} agents** | Consensus score: {X}%

### üî¥ Critical Issues ({count})
[findings...]

### üü° Warnings ({count})
<details><summary>Click to expand</summary>
[findings...]
</details>

### üí° Suggestions ({count})
<details><summary>Click to expand</summary>
[findings...]
</details>

---
<sub>Generated by AI Code Reviewer</sub>
```

## Error Handling

```python
async def post_review_safely(repo: str, pr: int, review: ConsolidatedReview):
    try:
        await self.post_review(repo, pr, review)
    except RateLimitExceeded:
        # Wait and retry
        await asyncio.sleep(60)
        await self.post_review(repo, pr, review)
    except PermissionDenied:
        # Log but don't crash
        logger.error(f"No permission to post review to {repo}#{pr}")
    except Exception as e:
        # Post error comment as fallback
        await self.post_comment(
            repo, pr, 
            f"‚ö†Ô∏è AI Review failed: {e}\n\nPlease check logs."
        )
```

## Configuration

```yaml
github:
  token: ${GITHUB_TOKEN}
  webhook_secret: ${GITHUB_WEBHOOK_SECRET}
  
  # Optional: GitHub App auth (for higher rate limits)
  app_id: ${GITHUB_APP_ID}
  private_key_path: ./github-app.pem
```

## Anti-Patterns

1. **Don't embed review logic** - Only fetch/post, delegate to orchestrator
2. **Don't ignore rate limits** - Implement proper backoff
3. **Don't skip signature validation** - Security critical
4. **Don't block webhook handler** - Return quickly, process async
5. **Don't hardcode repos/permissions** - Use configuration
